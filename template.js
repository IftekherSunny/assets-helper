// ----------------------------------------------------------------------------
// Assets Helper, a Javascript Assets Helper library
// Licensed under the MIT license.
// ----------------------------------------------------------------------------
// Copyright (C) Iftekher Sunny < iftekhersunny@hotmail.com >
// ----------------------------------------------------------------------------
(function ($, _, twig) {

    /////////////////////////////////////////////////////////
    //
    // instance of global object
    //
    /////////////////////////////////////////////////////////
    var root = this;

 

    /////////////////////////////////////////////////////////
    //
    // instance of assets object
    //
    /////////////////////////////////////////////////////////
    var Assets = root.Assets || {
        name: "assets-helper",
        version: "0.0.0"
    };



    /////////////////////////////////////////////////////////
    //
    // an array of loaded element
    //
    /////////////////////////////////////////////////////////
    Assets.loadedElement = [];



    /////////////////////////////////////////////////////////
    //
    // init
    //
    /////////////////////////////////////////////////////////
    Assets.init = function() {
        document.createElement("QuixTemplate");
        document.createElement("QuixHtml");
        document.createElement("QuixStyle");
        document.createElement("QuixScript");

        $(function () {
            $("QuixTemplate").css({ display: "none" })
        });
    }



    /////////////////////////////////////////////////////////
    //
    // get html markup by the given template and data
    //
    /////////////////////////////////////////////////////////
    Assets.html = function (templateID, data, htmlRenderId) {
        data = data || {};

        // check QuixHtml tag existence
        if (!$("QuixTemplate" + templateID + " QuixHtml").html()) return;

        var html = twig({
                data: $("QuixTemplate" + templateID + " QuixHtml").html()
            })
            .render(Object.assign(data, { $: $, _: _, Assets: Assets }));

        if (!htmlRenderId) return html;

        $(htmlRenderId).html(html);
    }



    /////////////////////////////////////////////////////////
    //
    // get css rules by the given template and data
    //
    /////////////////////////////////////////////////////////
    Assets.style = function (templateID, data, mountID) {
        data = data || {};

        // check QuixStyle tag existence
        if (!$("QuixTemplate" + templateID + " QuixStyle").html()) return;

        // making inline script content
        var script = twig({
                data: $("QuixTemplate" + templateID + " QuixStyle").html()
            })
            .render(Object.assign(data, { $: $, _: _, Assets: Assets }));

        // loading inline script
        var inlineScript = document.createElement("script");

        inlineScript.innerHTML = script;

        // if script already exists
        // then remove it
        if (mountID) {
            id = mountID.replace("#", "");
            inlineScript.id = id;
        } else {
            id = templateID.replace("#", "");
            inlineScript.id = id;
        }

        $("script#" + id).remove();
        
        document.body.appendChild(inlineScript); 
        
        Assets.load(templateID, mountID);
    }



    /////////////////////////////////////////////////////////
    //
    // loading script by the given template and data
    //
    /////////////////////////////////////////////////////////
    Assets.script = function (templateID, data, mountID) {
        data = data || {};
      
        // check QuixScript tag existence
        if(! $("QuixTemplate" + templateID + " QuixScript").html() ) return;
       
        // making inline script content
        var script = twig({
                data: $("QuixTemplate" + templateID + " QuixScript").html()
            })
            .render(Object.assign(data, { $: $, _: _, Assets: Assets }));

        // getting dependencies
        var filters = $("QuixTemplate" + templateID + " QuixScript").attr('dependencies')
                        ? $("QuixTemplate" + templateID + " QuixScript").attr('dependencies').split(",")
                        : [];

        // loading all dependencies of the inline script                
        if($.inArray(templateID, Assets.loadedElement) == -1) {
            for (key in filters) {
                var scriptTag = document.createElement("script");
				var src = "";
				
				// if quix loaded
                if(window.QUIX_URL) {
                    src = window.QUIX_URL + filters[key].replace(/\s/g, '');
                }

                scriptTag.src = src;
                document.head.appendChild(scriptTag);
            }
        }

        // loading inline script
        var inlineScript = document.createElement("script");
        
        inlineScript.innerHTML = script;

        // if script already exists
        // then remove it
        if(mountID) {
            id = mountID.replace("#", "");
            inlineScript.id = id;
        } else {
            id = templateID.replace("#", "");
            inlineScript.id = id;
        }

        $("script#" + id).remove();

        document.body.appendChild(inlineScript); 

        // saved loaded element
        Assets.loadedElement.push(templateID);
    }



    /////////////////////////////////////////////////////////
    //
    // rendering html template the given templateId and data
    //
    /////////////////////////////////////////////////////////
    Assets.render = function (templateID, data, mountID) {

        if(templateID.indexOf("#") == -1) {
            return twig({
                    data: templateID
                })
                .render(Object.assign(data, { $: $, _: _, Assets: Assets }));
        }

        var html = Assets.html(templateID, data),
            style = Assets.style(templateID, data, mountID),
            id = Math.random().toFixed(4);
       
        var output = "" +
            "<div id='" + templateID + "-" + id + "'>" +
                "<div>" +
                html +
                "</div>" +
            "</div>";

        if(!mountID) return output;    

        // loading style and html    
        $("div"+mountID).html(output);

        // loading script
        Assets.script(templateID, data);
    }



    /////////////////////////////////////////////////////////
    //
    // calling init
    //
    /////////////////////////////////////////////////////////
    Assets.init();



    /////////////////////////////////////////////////////////
    //
    // assigning Assets object to the Global object
    //
    /////////////////////////////////////////////////////////
    return root.Assets = Assets;

}(

    /////////////////////////////////////////////////////////
    //
    // determine jQuery existence
    //
    /////////////////////////////////////////////////////////
    window.$?


        /////////////////////////////////////////////////////////
        //
        // if jQuery loaded,
        // return instance of the loaded jQuery
        //
        /////////////////////////////////////////////////////////
        window.$ : window.jQuery ? window.jQuery : undefined,

    /////////////////////////////////////////////////////////
    //
    // determine lodash existence
    //
    /////////////////////////////////////////////////////////
    window._ ?


        /////////////////////////////////////////////////////////
        //
        // if lodash loaded,
        // return instance of the loaded lodash 
        //
        /////////////////////////////////////////////////////////
        window._ : undefined,
    

    /////////////////////////////////////////////////////////
    //
    // determine twigjs existence
    //
    /////////////////////////////////////////////////////////
    window.twig ?


        /////////////////////////////////////////////////////////
        //
        // if twigjs loaded,
        // return instance of the loaded twigjs
        //
        /////////////////////////////////////////////////////////
        window.twig


        /////////////////////////////////////////////////////////
        //
        // if twigjs doesn't loaded,
        // load twigjs ( version 0.8.9 )
        //
        /////////////////////////////////////////////////////////
        : (function () {
            var Twig = function (e) { return e.VERSION = "0.8.9", e }(Twig || {}); !function (e) { "use strict"; e.Templates.registerLoader("ajax", function (t, r, n, o) { var i, s, p = r.precompiled, a = this.parsers[r.parser] || this.parser.twig; if ("undefined" == typeof XMLHttpRequest) throw new e.Error('Unsupported platform: Unable to do ajax requests because there is no "XMLHTTPRequest" implementation'); return s = new XMLHttpRequest, s.onreadystatechange = function () { var l = null; 4 === s.readyState && (200 === s.status || window.cordova && 0 == s.status ? (e.log.debug("Got template ", s.responseText), l = !0 === p ? JSON.parse(s.responseText) : s.responseText, r.url = t, r.data = l, i = a.call(this, r), "function" == typeof n && n(i)) : "function" == typeof o && o(s)) }, s.open("GET", t, !!r.async), s.send(), !!r.async || i }) }(Twig = function (e) { "use strict"; function t(e, t) { var r = Object.prototype.toString.call(t).slice(8, -1); return void 0 !== t && null !== t && r === e } return e.trace = !1, e.debug = !1, e.cache = !0, e.placeholders = { parent: "{{|PARENT|}}" }, e.indexOf = function (e, t) { if (Array.prototype.hasOwnProperty("indexOf")) return e.indexOf(t); if (void 0 === e || null === e) throw new TypeError; var r = Object(e), n = r.length >>> 0; if (0 === n) return -1; var o = 0; if (arguments.length > 0 && ((o = Number(arguments[1])) !== o ? o = 0 : 0 !== o && o !== 1 / 0 && o !== -1 / 0 && (o = (o > 0 || -1) * Math.floor(Math.abs(o)))), o >= n) return -1; for (var i = o >= 0 ? o : Math.max(n - Math.abs(o), 0); i < n; i++)if (i in r && r[i] === t) return i; return e == t ? 0 : -1 }, e.forEach = function (e, t, r) { if (Array.prototype.forEach) return e.forEach(t, r); var n, o; if (null == e) throw new TypeError(" this is null or not defined"); var i = Object(e), s = i.length >>> 0; if ("[object Function]" != {}.toString.call(t)) throw new TypeError(t + " is not a function"); for (r && (n = r), o = 0; o < s;) { var p; o in i && (p = i[o], t.call(n, p, o, i)), o++ } }, e.merge = function (t, r, n) { return e.forEach(Object.keys(r), function (e) { (!n || e in t) && (t[e] = r[e]) }), t }, e.Error = function (e) { this.message = e, this.name = "TwigException", this.type = "TwigException" }, e.Error.prototype.toString = function () { return this.name + ": " + this.message }, e.log = { trace: function () { e.trace && console && console.log(Array.prototype.slice.call(arguments)) }, debug: function () { e.debug && console && console.log(Array.prototype.slice.call(arguments)) } }, "undefined" != typeof console ? void 0 !== console.error ? e.log.error = function () { console.error.apply(console, arguments) } : void 0 !== console.log && (e.log.error = function () { console.log.apply(console, arguments) }) : e.log.error = function () { }, e.ChildContext = function (e) { var t = function () { }; return t.prototype = e, new t }, e.token = {}, e.token.type = { output: "output", logic: "logic", comment: "comment", raw: "raw", output_whitespace_pre: "output_whitespace_pre", output_whitespace_post: "output_whitespace_post", output_whitespace_both: "output_whitespace_both", logic_whitespace_pre: "logic_whitespace_pre", logic_whitespace_post: "logic_whitespace_post", logic_whitespace_both: "logic_whitespace_both" }, e.token.definitions = [{ type: e.token.type.raw, open: "{% raw %}", close: "{% endraw %}" }, { type: e.token.type.raw, open: "{% verbatim %}", close: "{% endverbatim %}" }, { type: e.token.type.output_whitespace_pre, open: "{{-", close: "}}" }, { type: e.token.type.output_whitespace_post, open: "{{", close: "-}}" }, { type: e.token.type.output_whitespace_both, open: "{{-", close: "-}}" }, { type: e.token.type.logic_whitespace_pre, open: "{%-", close: "%}" }, { type: e.token.type.logic_whitespace_post, open: "{%", close: "-%}" }, { type: e.token.type.logic_whitespace_both, open: "{%-", close: "-%}" }, { type: e.token.type.output, open: "{{", close: "}}" }, { type: e.token.type.logic, open: "{%", close: "%}" }, { type: e.token.type.comment, open: "{#", close: "#}" }], e.token.strings = ['"', "'"], e.token.findStart = function (t) { var r, n, o, i, s = { position: null, close_position: null, def: null }; for (r = 0; r < e.token.definitions.length; r++)n = e.token.definitions[r], o = t.indexOf(n.open), i = t.indexOf(n.close), e.log.trace("Twig.token.findStart: ", "Searching for ", n.open, " found at ", o), o >= 0 && n.open.length !== n.close.length && i < 0 || (o >= 0 && (null === s.position || o < s.position) ? (s.position = o, s.def = n, s.close_position = i) : o >= 0 && null !== s.position && o === s.position && (n.open.length > s.def.open.length ? (s.position = o, s.def = n, s.close_position = i) : n.open.length === s.def.open.length && (n.close.length, s.def.close.length, i >= 0 && i < s.close_position && (s.position = o, s.def = n, s.close_position = i)))); return delete s.close_position, s }, e.token.findEnd = function (t, r, n) { for (var o, i, s = null, p = !1, a = 0, l = null, c = null, u = null, f = null, h = null, g = null; !p;) { if (l = null, c = null, !((u = t.indexOf(r.close, a)) >= 0)) throw new e.Error("Unable to find closing bracket '" + r.close + "' opened near template position " + n); if (s = u, p = !0, r.type === e.token.type.comment) break; if (r.type === e.token.type.raw) break; for (i = e.token.strings.length, o = 0; o < i; o += 1)(h = t.indexOf(e.token.strings[o], a)) > 0 && h < u && (null === l || h < l) && (l = h, c = e.token.strings[o]); if (null !== l) for (f = l + 1, s = null, p = !1; ;) { if ((g = t.indexOf(c, f)) < 0) throw "Unclosed string in template"; if ("\\" !== t.substr(g - 1, 1)) { a = g + 1; break } f = g + 1 } } return s }, e.tokenize = function (t) { for (var r = [], n = 0, o = null, i = null; t.length > 0;)if (o = e.token.findStart(t), e.log.trace("Twig.tokenize: ", "Found token: ", o), null !== o.position) { if (o.position > 0 && r.push({ type: e.token.type.raw, value: t.substring(0, o.position) }), t = t.substr(o.position + o.def.open.length), n += o.position + o.def.open.length, i = e.token.findEnd(t, o.def, n), e.log.trace("Twig.tokenize: ", "Token ends at ", i), r.push({ type: o.def.type, value: t.substring(0, i).trim() }), "\n" === t.substr(i + o.def.close.length, 1)) switch (o.def.type) { case "logic_whitespace_pre": case "logic_whitespace_post": case "logic_whitespace_both": case "logic": i += 1 }t = t.substr(i + o.def.close.length), n += i + o.def.close.length } else r.push({ type: e.token.type.raw, value: t }), t = ""; return r }, e.compile = function (t) { try { for (var r = [], n = [], o = [], i = null, s = null, p = null, a = null, l = null, c = null, u = null, f = null, h = null, g = null, y = null, d = null, m = function (t) { e.expression.compile.apply(this, [t]), n.length > 0 ? o.push(t) : r.push(t) }, x = function (t) { if (s = e.logic.compile.apply(this, [t]), g = s.type, y = e.logic.handler[g].open, d = e.logic.handler[g].next, e.log.trace("Twig.compile: ", "Compiled logic token to ", s, " next is: ", d, " open is : ", y), void 0 !== y && !y) { if (a = n.pop(), u = e.logic.handler[a.type], e.indexOf(u.next, g) < 0) throw new Error(g + " not expected after a " + a.type); a.output = a.output || [], a.output = a.output.concat(o), o = [], h = { type: e.token.type.logic, token: a }, n.length > 0 ? o.push(h) : r.push(h) } void 0 !== d && d.length > 0 ? (e.log.trace("Twig.compile: ", "Pushing ", s, " to logic stack."), n.length > 0 && ((a = n.pop()).output = a.output || [], a.output = a.output.concat(o), n.push(a), o = []), n.push(s)) : void 0 !== y && y && (h = { type: e.token.type.logic, token: s }, n.length > 0 ? o.push(h) : r.push(h)) }; t.length > 0;) { switch (i = t.shift(), l = r[r.length - 1], c = o[o.length - 1], f = t[0], e.log.trace("Compiling token ", i), i.type) { case e.token.type.raw: n.length > 0 ? o.push(i) : r.push(i); break; case e.token.type.logic: x.call(this, i); break; case e.token.type.comment: break; case e.token.type.output: m.call(this, i); break; case e.token.type.logic_whitespace_pre: case e.token.type.logic_whitespace_post: case e.token.type.logic_whitespace_both: case e.token.type.output_whitespace_pre: case e.token.type.output_whitespace_post: case e.token.type.output_whitespace_both: switch (i.type !== e.token.type.output_whitespace_post && i.type !== e.token.type.logic_whitespace_post && (l && l.type === e.token.type.raw && (r.pop(), null === l.value.match(/^\s*$/) && (l.value = l.value.trim(), r.push(l))), c && c.type === e.token.type.raw && (o.pop(), null === c.value.match(/^\s*$/) && (c.value = c.value.trim(), o.push(c)))), i.type) { case e.token.type.output_whitespace_pre: case e.token.type.output_whitespace_post: case e.token.type.output_whitespace_both: m.call(this, i); break; case e.token.type.logic_whitespace_pre: case e.token.type.logic_whitespace_post: case e.token.type.logic_whitespace_both: x.call(this, i) }i.type !== e.token.type.output_whitespace_pre && i.type !== e.token.type.logic_whitespace_pre && f && f.type === e.token.type.raw && (t.shift(), null === f.value.match(/^\s*$/) && (f.value = f.value.trim(), t.unshift(f))) }e.log.trace("Twig.compile: ", " Output: ", r, " Logic Stack: ", n, " Pending Output: ", o) } if (n.length > 0) throw p = n.pop(), new Error("Unable to find an end tag for " + p.type + ", expecting one of " + p.next); return r } catch (t) { if (e.log.error("Error compiling twig template " + this.id + ": "), t.stack ? e.log.error(t.stack) : e.log.error(t.toString()), this.options.rethrow) throw t } }, e.parse = function (t, r) { try { var n = [], o = !0, i = this; return e.forEach(t, function (t) { switch (e.log.debug("Twig.parse: ", "Parsing token: ", t), t.type) { case e.token.type.raw: n.push(e.filters.raw(t.value)); break; case e.token.type.logic: var s = t.token, p = e.logic.parse.apply(i, [s, r, o]); void 0 !== p.chain && (o = p.chain), void 0 !== p.context && (r = p.context), void 0 !== p.output && n.push(p.output); break; case e.token.type.comment: break; case e.token.type.output_whitespace_pre: case e.token.type.output_whitespace_post: case e.token.type.output_whitespace_both: case e.token.type.output: e.log.debug("Twig.parse: ", "Output token: ", t.stack), n.push(e.expression.parse.apply(i, [t.stack, r])) } }), e.output.apply(this, [n]) } catch (t) { if (e.log.error("Error parsing twig template " + this.id + ": "), t.stack ? e.log.error(t.stack) : e.log.error(t.toString()), this.options.rethrow) throw t; if (e.debug) return t.toString() } }, e.prepare = function (t) { var r, n; return e.log.debug("Twig.prepare: ", "Tokenizing ", t), n = e.tokenize.apply(this, [t]), e.log.debug("Twig.prepare: ", "Compiling ", n), r = e.compile.apply(this, [n]), e.log.debug("Twig.prepare: ", "Compiled ", r), r }, e.output = function (t) { if (!this.options.autoescape) return t.join(""); var r = "html"; "string" == typeof this.options.autoescape && (r = this.options.autoescape); var n = []; return e.forEach(t, function (t) { t && !0 !== t.twig_markup && t.twig_markup != r && (t = e.filters.escape(t, [r])), n.push(t) }), e.Markup(n.join("")) }, e.Templates = { loaders: {}, parsers: {}, registry: {} }, e.validateId = function (t) { if ("prototype" === t) throw new e.Error(t + " is not a valid twig identifier"); if (e.cache && e.Templates.registry.hasOwnProperty(t)) throw new e.Error("There is already a template with the ID " + t); return !0 }, e.Templates.registerLoader = function (t, r, n) { if ("function" != typeof r) throw new e.Error("Unable to add loader for " + t + ": Invalid function reference given."); n && (r = r.bind(n)), this.loaders[t] = r }, e.Templates.unRegisterLoader = function (e) { this.isRegisteredLoader(e) && delete this.loaders[e] }, e.Templates.isRegisteredLoader = function (e) { return this.loaders.hasOwnProperty(e) }, e.Templates.registerParser = function (t, r, n) { if ("function" != typeof r) throw new e.Error("Unable to add parser for " + t + ": Invalid function regerence given."); n && (r = r.bind(n)), this.parsers[t] = r }, e.Templates.unRegisterParser = function (e) { this.isRegisteredParser(e) && delete this.parsers[e] }, e.Templates.isRegisteredParser = function (e) { return this.parsers.hasOwnProperty(e) }, e.Templates.save = function (t) { if (void 0 === t.id) throw new e.Error("Unable to save template with no id"); e.Templates.registry[t.id] = t }, e.Templates.load = function (t) { return e.Templates.registry.hasOwnProperty(t) ? e.Templates.registry[t] : null }, e.Templates.loadRemote = function (t, r, n, o) { return void 0 === r.async && (r.async = !0), void 0 === r.id && (r.id = t), e.cache && e.Templates.registry.hasOwnProperty(r.id) ? ("function" == typeof n && n(e.Templates.registry[r.id]), e.Templates.registry[r.id]) : (r.parser = r.parser || "twig", (this.loaders[r.method] || this.loaders.fs).apply(this, arguments)) }, e.Template = function (r) { var n = r.data, o = r.id, i = r.blocks, s = r.macros || {}, p = r.base, a = r.path, l = r.url, c = r.name, u = r.method, f = r.options; this.id = o, this.method = u, this.base = p, this.path = a, this.url = l, this.name = c, this.macros = s, this.options = f, this.reset(i), t("String", n) ? this.tokens = e.prepare.apply(this, [n]) : this.tokens = n, void 0 !== o && e.Templates.save(this) }, e.Template.prototype.reset = function (t) { e.log.debug("Twig.Template.reset", "Reseting template " + this.id), this.blocks = {}, this.importedBlocks = [], this.originalBlockTokens = {}, this.child = { blocks: t || {} }, this.extend = null }, e.Template.prototype.render = function (t, r) { r = r || {}; var n, o; if (this.context = t || {}, this.reset(), r.blocks && (this.blocks = r.blocks), r.macros && (this.macros = r.macros), n = e.parse.apply(this, [this.tokens, this.context]), this.extend) { var i; return this.options.allowInlineIncludes && (i = e.Templates.load(this.extend)) && (i.options = this.options), i || (o = e.path.parsePath(this, this.extend), i = e.Templates.loadRemote(o, { method: this.getLoaderMethod(), base: this.base, async: !1, id: o, options: this.options })), this.parent = i, this.parent.render(this.context, { blocks: this.blocks }) } return "blocks" == r.output ? this.blocks : "macros" == r.output ? this.macros : n }, e.Template.prototype.importFile = function (t) { var r, n; if (!this.url && this.options.allowInlineIncludes) { if (t = this.path ? this.path + "/" + t : t, !(n = e.Templates.load(t)) && !(n = e.Templates.loadRemote(r, { id: t, method: this.getLoaderMethod(), async: !1, options: this.options }))) throw new e.Error("Unable to find the template " + t); return n.options = this.options, n } return r = e.path.parsePath(this, t), n = e.Templates.loadRemote(r, { method: this.getLoaderMethod(), base: this.base, async: !1, options: this.options, id: r }) }, e.Template.prototype.importBlocks = function (t, r) { var n = this.importFile(t), o = this.context, i = this; r = r || !1, n.render(o), e.forEach(Object.keys(n.blocks), function (e) { (r || void 0 === i.blocks[e]) && (i.blocks[e] = n.blocks[e], i.importedBlocks.push(e)) }) }, e.Template.prototype.importMacros = function (t) { var r = e.path.parsePath(this, t); return e.Templates.loadRemote(r, { method: this.getLoaderMethod(), async: !1, id: r }) }, e.Template.prototype.getLoaderMethod = function () { return this.path ? "fs" : this.url ? "ajax" : this.method || "fs" }, e.Template.prototype.compile = function (t) { return e.compiler.compile(this, t) }, e.Markup = function (e, t) { return void 0 === t && (t = !0), "string" == typeof e && e.length > 0 && ((e = new String(e)).twig_markup = t), e }, e }(Twig || {})), function (e) { "use strict"; var t, r; try { t = require("fs"), r = require("path") } catch (e) { } e.Templates.registerLoader("fs", function (n, o, i, s) { var p, a = null, l = o.precompiled, c = this.parsers[o.parser] || this.parser.twig; if (!t || !r) throw new e.Error('Unsupported platform: Unable to load from file because there is no "fs" or "path" implementation'); var u = function (e, t) { e ? "function" == typeof s && s(e) : (!0 === l && (t = JSON.parse(t)), o.data = t, o.path = o.path || n, p = c.call(this, o), "function" == typeof i && i(p)) }; if (o.path = o.path || n, o.async) return t.stat(o.path, function (r, i) { if (r || !i.isFile()) throw new e.Error("Unable to find template file " + n); t.readFile(o.path, "utf8", u) }), !0; if (!t.statSync(o.path).isFile()) throw new e.Error("Unable to find template file " + n); return a = t.readFileSync(o.path, "utf8"), u(void 0, a), p }) }(Twig), function (e) { "use strict"; e.Templates.registerParser("source", function (e) { return e.data || "" }) }(Twig), function (e) { "use strict"; e.Templates.registerParser("twig", function (t) { return new e.Template(t) }) }(Twig), function () { "use strict"; String.prototype.trim || (String.prototype.trim = function () { return this.replace(/^\s+|\s+$/g, "") }), Object.keys || (Object.keys = function (e) { if (e !== Object(e)) throw new TypeError("Object.keys called on non-object"); var t, r = []; for (t in e) Object.prototype.hasOwnProperty.call(e, t) && r.push(t); return r }) }(); var Twig = function (e) { "use strict"; for (e.logic = {}, e.logic.type = { if_: "Twig.logic.type.if", endif: "Twig.logic.type.endif", for_: "Twig.logic.type.for", endfor: "Twig.logic.type.endfor", else_: "Twig.logic.type.else", elseif: "Twig.logic.type.elseif", set: "Twig.logic.type.set", setcapture: "Twig.logic.type.setcapture", endset: "Twig.logic.type.endset", filter: "Twig.logic.type.filter", endfilter: "Twig.logic.type.endfilter", shortblock: "Twig.logic.type.shortblock", block: "Twig.logic.type.block", endblock: "Twig.logic.type.endblock", extends_: "Twig.logic.type.extends", use: "Twig.logic.type.use", include: "Twig.logic.type.include", spaceless: "Twig.logic.type.spaceless", endspaceless: "Twig.logic.type.endspaceless", macro: "Twig.logic.type.macro", endmacro: "Twig.logic.type.endmacro", import_: "Twig.logic.type.import", from: "Twig.logic.type.from", embed: "Twig.logic.type.embed", endembed: "Twig.logic.type.endembed" }, e.logic.definitions = [{ type: e.logic.type.if_, regex: /^if\s+([\s\S]+)$/, next: [e.logic.type.else_, e.logic.type.elseif, e.logic.type.endif], open: !0, compile: function (t) { var r = t.match[1]; return t.stack = e.expression.compile.apply(this, [{ type: e.expression.type.expression, value: r }]).stack, delete t.match, t }, parse: function (t, r, n) { var o = ""; return n = !0, e.expression.parse.apply(this, [t.stack, r]) && (n = !1, o = e.parse.apply(this, [t.output, r])), { chain: n, output: o } } }, { type: e.logic.type.elseif, regex: /^elseif\s+([^\s].*)$/, next: [e.logic.type.else_, e.logic.type.elseif, e.logic.type.endif], open: !1, compile: function (t) { var r = t.match[1]; return t.stack = e.expression.compile.apply(this, [{ type: e.expression.type.expression, value: r }]).stack, delete t.match, t }, parse: function (t, r, n) { var o = ""; return n && !0 === e.expression.parse.apply(this, [t.stack, r]) && (n = !1, o = e.parse.apply(this, [t.output, r])), { chain: n, output: o } } }, { type: e.logic.type.else_, regex: /^else$/, next: [e.logic.type.endif, e.logic.type.endfor], open: !1, parse: function (t, r, n) { var o = ""; return n && (o = e.parse.apply(this, [t.output, r])), { chain: n, output: o } } }, { type: e.logic.type.endif, regex: /^endif$/, next: [], open: !1 }, { type: e.logic.type.for_, regex: /^for\s+([a-zA-Z0-9_,\s]+)\s+in\s+([^\s].*?)(?:\s+if\s+([^\s].*))?$/, next: [e.logic.type.else_, e.logic.type.endfor], open: !0, compile: function (t) { var r = t.match[1], n = t.match[2], o = t.match[3], i = null; if (t.key_var = null, t.value_var = null, r.indexOf(",") >= 0) { if (2 !== (i = r.split(",")).length) throw new e.Error("Invalid expression in for loop: " + r); t.key_var = i[0].trim(), t.value_var = i[1].trim() } else t.value_var = r; return t.expression = e.expression.compile.apply(this, [{ type: e.expression.type.expression, value: n }]).stack, o && (t.conditional = e.expression.compile.apply(this, [{ type: e.expression.type.expression, value: o }]).stack), delete t.match, t }, parse: function (t, r, n) { var o, i, s = e.expression.parse.apply(this, [t.expression, r]), p = [], a = 0, l = this, c = t.conditional, u = function (e, t) { var n = void 0 !== c; return { index: e + 1, index0: e, revindex: n ? void 0 : t - e, revindex0: n ? void 0 : t - e - 1, first: 0 === e, last: n ? void 0 : e === t - 1, length: n ? void 0 : t, parent: r } }, f = function (n, i) { var s = e.ChildContext(r); s[t.value_var] = i, t.key_var && (s[t.key_var] = n), s.loop = u(a, o), (void 0 === c || e.expression.parse.apply(l, [c, s])) && (p.push(e.parse.apply(l, [t.output, s])), a += 1), delete s.loop, delete s[t.value_var], delete s[t.key_var], e.merge(r, s, !0) }; return e.lib.is("Array", s) ? (o = s.length, e.forEach(s, function (e) { f(a, e) })) : e.lib.is("Object", s) && (i = void 0 !== s._keys ? s._keys : Object.keys(s), o = i.length, e.forEach(i, function (e) { "_keys" !== e && f(e, s[e]) })), n = 0 === p.length, { chain: n, output: e.output.apply(this, [p]) } } }, { type: e.logic.type.endfor, regex: /^endfor$/, next: [], open: !1 }, { type: e.logic.type.set, regex: /^set\s+([a-zA-Z0-9_,\s]+)\s*=\s*([\s\S]+)$/, next: [], open: !0, compile: function (t) { var r = t.match[1].trim(), n = t.match[2], o = e.expression.compile.apply(this, [{ type: e.expression.type.expression, value: n }]).stack; return t.key = r, t.expression = o, delete t.match, t }, parse: function (t, r, n) { var o = e.expression.parse.apply(this, [t.expression, r]); return r[t.key] = o, { chain: n, context: r } } }, { type: e.logic.type.setcapture, regex: /^set\s+([a-zA-Z0-9_,\s]+)$/, next: [e.logic.type.endset], open: !0, compile: function (e) { var t = e.match[1].trim(); return e.key = t, delete e.match, e }, parse: function (t, r, n) { var o = e.parse.apply(this, [t.output, r]), i = t.key; return this.context[i] = o, r[i] = o, { chain: n, context: r } } }, { type: e.logic.type.endset, regex: /^endset$/, next: [], open: !1 }, { type: e.logic.type.filter, regex: /^filter\s+(.+)$/, next: [e.logic.type.endfilter], open: !0, compile: function (t) { var r = "|" + t.match[1].trim(); return t.stack = e.expression.compile.apply(this, [{ type: e.expression.type.expression, value: r }]).stack, delete t.match, t }, parse: function (t, r, n) { var o = e.parse.apply(this, [t.output, r]), i = [{ type: e.expression.type.string, value: o }].concat(t.stack); return { chain: n, output: e.expression.parse.apply(this, [i, r]) } } }, { type: e.logic.type.endfilter, regex: /^endfilter$/, next: [], open: !1 }, { type: e.logic.type.block, regex: /^block\s+([a-zA-Z0-9_]+)$/, next: [e.logic.type.endblock], open: !0, compile: function (e) { return e.block = e.match[1].trim(), delete e.match, e }, parse: function (t, r, n) { var o, i, s = e.indexOf(this.importedBlocks, t.block) > -1, p = this.blocks[t.block] && e.indexOf(this.blocks[t.block], e.placeholders.parent) > -1; return (void 0 === this.blocks[t.block] || s || p || r.loop || t.overwrite) && (o = t.expression ? e.expression.parse.apply(this, [{ type: e.expression.type.string, value: e.expression.parse.apply(this, [t.output, r]) }, r]) : e.expression.parse.apply(this, [{ type: e.expression.type.string, value: e.parse.apply(this, [t.output, r]) }, r]), s && this.importedBlocks.splice(this.importedBlocks.indexOf(t.block), 1), this.blocks[t.block] = p ? e.Markup(this.blocks[t.block].replace(e.placeholders.parent, o)) : o, this.originalBlockTokens[t.block] = { type: t.type, block: t.block, output: t.output, overwrite: !0 }), i = this.child.blocks[t.block] ? this.child.blocks[t.block] : this.blocks[t.block], { chain: n, output: i } } }, { type: e.logic.type.shortblock, regex: /^block\s+([a-zA-Z0-9_]+)\s+(.+)$/, next: [], open: !0, compile: function (t) { return t.expression = t.match[2].trim(), t.output = e.expression.compile({ type: e.expression.type.expression, value: t.expression }).stack, t.block = t.match[1].trim(), delete t.match, t }, parse: function (t, r, n) { return e.logic.handler[e.logic.type.block].parse.apply(this, arguments) } }, { type: e.logic.type.endblock, regex: /^endblock(?:\s+([a-zA-Z0-9_]+))?$/, next: [], open: !1 }, { type: e.logic.type.extends_, regex: /^extends\s+(.+)$/, next: [], open: !0, compile: function (t) { var r = t.match[1].trim(); return delete t.match, t.stack = e.expression.compile.apply(this, [{ type: e.expression.type.expression, value: r }]).stack, t }, parse: function (t, r, n) { var o = e.expression.parse.apply(this, [t.stack, r]); return this.extend = o, { chain: n, output: "" } } }, { type: e.logic.type.use, regex: /^use\s+(.+)$/, next: [], open: !0, compile: function (t) { var r = t.match[1].trim(); return delete t.match, t.stack = e.expression.compile.apply(this, [{ type: e.expression.type.expression, value: r }]).stack, t }, parse: function (t, r, n) { var o = e.expression.parse.apply(this, [t.stack, r]); return this.importBlocks(o), { chain: n, output: "" } } }, { type: e.logic.type.include, regex: /^include\s+(ignore missing\s+)?(.+?)\s*(?:with\s+([\S\s]+?))?\s*(only)?$/, next: [], open: !0, compile: function (t) { var r = t.match, n = void 0 !== r[1], o = r[2].trim(), i = r[3], s = void 0 !== r[4] && r[4].length; return delete t.match, t.only = s, t.includeMissing = n, t.stack = e.expression.compile.apply(this, [{ type: e.expression.type.expression, value: o }]).stack, void 0 !== i && (t.withStack = e.expression.compile.apply(this, [{ type: e.expression.type.expression, value: i.trim() }]).stack), t }, parse: function (t, r, n) { var o, i, s, p = {}; if (t.only || (p = e.ChildContext(r)), void 0 !== t.withStack) { o = e.expression.parse.apply(this, [t.withStack, r]); for (i in o) o.hasOwnProperty(i) && (p[i] = o[i]) } var a = e.expression.parse.apply(this, [t.stack, p]); return s = a instanceof e.Template ? a : this.importFile(a), { chain: n, output: s.render(p) } } }, { type: e.logic.type.spaceless, regex: /^spaceless$/, next: [e.logic.type.endspaceless], open: !0, parse: function (t, r, n) { var o = />\s+</g; return { chain: n, output: e.parse.apply(this, [t.output, r]).replace(o, "><").trim() } } }, { type: e.logic.type.endspaceless, regex: /^endspaceless$/, next: [], open: !1 }, { type: e.logic.type.macro, regex: /^macro\s+([a-zA-Z0-9_]+)\s*\(\s*((?:[a-zA-Z0-9_]+(?:,\s*)?)*)\s*\)$/, next: [e.logic.type.endmacro], open: !0, compile: function (t) { for (var r = t.match[1], n = t.match[2].split(/[\s,]+/), o = 0; o < n.length; o++)for (var i = 0; i < n.length; i++)if (n[o] === n[i] && o !== i) throw new e.Error("Duplicate arguments for parameter: " + n[o]); return t.macroName = r, t.parameters = n, delete t.match, t }, parse: function (t, r, n) { var o = this; return this.macros[t.macroName] = function () { for (var r = { _self: o.macros }, n = 0; n < t.parameters.length; n++) { var i = t.parameters[n]; void 0 !== arguments[n] ? r[i] = arguments[n] : r[i] = void 0 } return e.parse.apply(o, [t.output, r]) }, { chain: n, output: "" } } }, { type: e.logic.type.endmacro, regex: /^endmacro$/, next: [], open: !1 }, { type: e.logic.type.import_, regex: /^import\s+(.+)\s+as\s+([a-zA-Z0-9_]+)$/, next: [], open: !0, compile: function (t) { var r = t.match[1].trim(), n = t.match[2].trim(); return delete t.match, t.expression = r, t.contextName = n, t.stack = e.expression.compile.apply(this, [{ type: e.expression.type.expression, value: r }]).stack, t }, parse: function (t, r, n) { if ("_self" !== t.expression) { var o = e.expression.parse.apply(this, [t.stack, r]), i = this.importFile(o || t.expression); r[t.contextName] = i.render({}, { output: "macros" }) } else r[t.contextName] = this.macros; return { chain: n, output: "" } } }, { type: e.logic.type.from, regex: /^from\s+(.+)\s+import\s+([a-zA-Z0-9_, ]+)$/, next: [], open: !0, compile: function (t) { for (var r = t.match[1].trim(), n = t.match[2].trim().split(/[ ,]+/), o = {}, i = 0; i < n.length; i++) { var s = n[i], p = s.match(/^([a-zA-Z0-9_]+)\s+(.+)\s+as\s+([a-zA-Z0-9_]+)$/); p ? o[p[1].trim()] = p[2].trim() : s.match(/^([a-zA-Z0-9_]+)$/) && (o[s] = s) } return delete t.match, t.expression = r, t.macroNames = o, t.stack = e.expression.compile.apply(this, [{ type: e.expression.type.expression, value: r }]).stack, t }, parse: function (t, r, n) { var o; if ("_self" !== t.expression) { var i = e.expression.parse.apply(this, [t.stack, r]); o = this.importFile(i || t.expression).render({}, { output: "macros" }) } else o = this.macros; for (var s in t.macroNames) o.hasOwnProperty(s) && (r[t.macroNames[s]] = o[s]); return { chain: n, output: "" } } }, { type: e.logic.type.embed, regex: /^embed\s+(.+?)(?:\s|$)(ignore missing(?:\s|$))?(?:with\s+([\S\s]+?))?(?:\s|$)(only)?$/, next: [e.logic.type.endembed], open: !0, compile: function (t) { var r = t.match, n = void 0 !== r[1], o = r[2].trim(), i = r[3], s = void 0 !== r[4] && r[4].length; return delete t.match, t.only = s, t.includeMissing = n, t.stack = e.expression.compile.apply(this, [{ type: e.expression.type.expression, value: o }]).stack, void 0 !== i && (t.withStack = e.expression.compile.apply(this, [{ type: e.expression.type.expression, value: i.trim() }]).stack), t }, parse: function (t, r, n) { var o, i, s, p = {}; if (!t.only) for (i in r) r.hasOwnProperty(i) && (p[i] = r[i]); if (void 0 !== t.withStack) { o = e.expression.parse.apply(this, [t.withStack, r]); for (i in o) o.hasOwnProperty(i) && (p[i] = o[i]) } var a = e.expression.parse.apply(this, [t.stack, p]); s = a instanceof e.Template ? a : this.importFile(a), this.blocks = {}; e.parse.apply(this, [t.output, p]); return { chain: n, output: s.render(p, { blocks: this.blocks }) } } }, { type: e.logic.type.endembed, regex: /^endembed$/, next: [], open: !1 }], e.logic.handler = {}, e.logic.extendType = function (t, r) { r = r || "Twig.logic.type" + t, e.logic.type[t] = r }, e.logic.extend = function (t) { if (!t.type) throw new e.Error("Unable to extend logic definition. No type provided for " + t); e.logic.extendType(t.type), e.logic.handler[t.type] = t }; e.logic.definitions.length > 0;)e.logic.extend(e.logic.definitions.shift()); return e.logic.compile = function (t) { var r = t.value.trim(), n = e.logic.tokenize.apply(this, [r]), o = e.logic.handler[n.type]; return o.compile && (n = o.compile.apply(this, [n]), e.log.trace("Twig.logic.compile: ", "Compiled logic token to ", n)), n }, e.logic.tokenize = function (t) { var r = {}, n = null, o = null, i = null, s = null, p = null, a = null; t = t.trim(); for (n in e.logic.handler) if (e.logic.handler.hasOwnProperty(n)) for (o = e.logic.handler[n].type, s = [], (i = e.logic.handler[n].regex) instanceof Array ? s = i : s.push(i); s.length > 0;)if (p = s.shift(), null !== (a = p.exec(t.trim()))) return r.type = o, r.match = a, e.log.trace("Twig.logic.tokenize: ", "Matched a ", o, " regular expression of ", a), r; throw new e.Error("Unable to parse '" + t.trim() + "'") }, e.logic.parse = function (t, r, n) { var o, i = ""; return r = r || {}, e.log.debug("Twig.logic.parse: ", "Parsing logic token ", t), (o = e.logic.handler[t.type]).parse && (i = o.parse.apply(this, [t, r, n])), i }, e }((Twig = function (e) { e.lib = {}; var t = function () { function e() { var t = arguments[0], r = e.cache; return r[t] && r.hasOwnProperty(t) || (r[t] = e.parse(t)), e.format.call(null, r[t], arguments) } function t(e) { return Object.prototype.toString.call(e).slice(8, -1).toLowerCase() } function r(e, t) { return Array(t + 1).join(e) } var n = { not_string: /[^s]/, number: /[diefg]/, json: /[j]/, not_json: /[^j]/, text: /^[^\x25]+/, modulo: /^\x25{2}/, placeholder: /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijosuxX])/, key: /^([a-z_][a-z_\d]*)/i, key_access: /^\.([a-z_][a-z_\d]*)/i, index_access: /^\[(\d+)\]/, sign: /^[\+\-]/ }; e.format = function (o, i) { var s, p, a, l, c, u, f, h = 1, g = o.length, y = "", d = [], m = !0, x = ""; for (p = 0; p < g; p++)if ("string" === (y = t(o[p]))) d[d.length] = o[p]; else if ("array" === y) { if ((l = o[p])[2]) for (s = i[h], a = 0; a < l[2].length; a++) { if (!s.hasOwnProperty(l[2][a])) throw new Error(e("[sprintf] property '%s' does not exist", l[2][a])); s = s[l[2][a]] } else s = l[1] ? i[l[1]] : i[h++]; if ("function" == t(s) && (s = s()), n.not_string.test(l[8]) && n.not_json.test(l[8]) && "number" != t(s) && isNaN(s)) throw new TypeError(e("[sprintf] expecting number but found %s", t(s))); switch (n.number.test(l[8]) && (m = s >= 0), l[8]) { case "b": s = s.toString(2); break; case "c": s = String.fromCharCode(s); break; case "d": case "i": s = parseInt(s, 10); break; case "j": s = JSON.stringify(s, null, l[6] ? parseInt(l[6]) : 0); break; case "e": s = l[7] ? s.toExponential(l[7]) : s.toExponential(); break; case "f": s = l[7] ? parseFloat(s).toFixed(l[7]) : parseFloat(s); break; case "g": s = l[7] ? parseFloat(s).toPrecision(l[7]) : parseFloat(s); break; case "o": s = s.toString(8); break; case "s": s = (s = String(s)) && l[7] ? s.substring(0, l[7]) : s; break; case "u": s >>>= 0; break; case "x": s = s.toString(16); break; case "X": s = s.toString(16).toUpperCase() }n.json.test(l[8]) ? d[d.length] = s : (!n.number.test(l[8]) || m && !l[3] ? x = "" : (x = m ? "+" : "-", s = s.toString().replace(n.sign, "")), u = l[4] ? "0" === l[4] ? "0" : l[4].charAt(1) : " ", f = l[6] - (x + s).length, c = l[6] && f > 0 ? r(u, f) : "", d[d.length] = l[5] ? x + s + c : "0" === u ? x + c + s : c + x + s) } return d.join("") }, e.cache = {}, e.parse = function (e) { for (var t = e, r = [], o = [], i = 0; t;) { if (null !== (r = n.text.exec(t))) o[o.length] = r[0]; else if (null !== (r = n.modulo.exec(t))) o[o.length] = "%"; else { if (null === (r = n.placeholder.exec(t))) throw new SyntaxError("[sprintf] unexpected placeholder"); if (r[2]) { i |= 1; var s = [], p = r[2], a = []; if (null === (a = n.key.exec(p))) throw new SyntaxError("[sprintf] failed to parse named argument key"); for (s[s.length] = a[1]; "" !== (p = p.substring(a[0].length));)if (null !== (a = n.key_access.exec(p))) s[s.length] = a[1]; else { if (null === (a = n.index_access.exec(p))) throw new SyntaxError("[sprintf] failed to parse named argument key"); s[s.length] = a[1] } r[2] = s } else i |= 2; if (3 === i) throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported"); o[o.length] = r } t = t.substring(r[0].length) } return o }; return { sprintf: e, vsprintf: function (t, r, n) { return (n = (r || []).slice(0)).splice(0, 0, t), e.apply(null, n) } } }(), r = t.sprintf, n = t.vsprintf; return e.lib.sprintf = r, e.lib.vsprintf = n, function () { function t(e) { return (e = Math.abs(e) % 100) % 10 == 1 && 11 != e ? "st" : e % 10 == 2 && 12 != e ? "nd" : e % 10 == 3 && 13 != e ? "rd" : "th" } function r(e) { var t = new Date(e.getFullYear() + 1, 0, 4); return (t - e) / 864e5 < 7 && (e.getDay() + 6) % 7 < (t.getDay() + 6) % 7 ? t.getFullYear() : e.getMonth() > 0 || e.getDate() >= 4 ? e.getFullYear() : e.getFullYear() - ((e.getDay() + 6) % 7 - e.getDate() > 2 ? 1 : 0) } function n(e) { var t = new Date(r(e), 0, 4); return t.setDate(t.getDate() - (t.getDay() + 6) % 7), parseInt((e - t) / 6048e5) + 1 } var o = "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(","), i = "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","), s = "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","), p = "January,February,March,April,May,June,July,August,September,October,November,December".split(","); e.lib.formatDate = function (e, a) { if ("string" != typeof a || /^\s*$/.test(a)) return e + ""; var l = new Date(e.getFullYear(), 0, 1), c = e; return a.replace(/[dDjlNSwzWFmMntLoYyaABgGhHisuU]/g, function (e) { switch (e) { case "d": return ("0" + c.getDate()).replace(/^.+(..)$/, "$1"); case "D": return o[c.getDay()]; case "j": return c.getDate(); case "l": return i[c.getDay()]; case "N": return (c.getDay() + 6) % 7 + 1; case "S": return t(c.getDate()); case "w": return c.getDay(); case "z": return Math.ceil((l - c) / 864e5); case "W": return ("0" + n(c)).replace(/^.(..)$/, "$1"); case "F": return p[c.getMonth()]; case "m": return ("0" + (c.getMonth() + 1)).replace(/^.+(..)$/, "$1"); case "M": return s[c.getMonth()]; case "n": return c.getMonth() + 1; case "t": return new Date(c.getFullYear(), c.getMonth() + 1, -1).getDate(); case "L": return 29 == new Date(c.getFullYear(), 1, 29).getDate() ? 1 : 0; case "o": return r(c); case "Y": return c.getFullYear(); case "y": return (c.getFullYear() + "").replace(/^.+(..)$/, "$1"); case "a": return c.getHours() < 12 ? "am" : "pm"; case "A": return c.getHours() < 12 ? "AM" : "PM"; case "B": return Math.floor(1e3 * ((c.getUTCHours() + 1) % 24 + c.getUTCMinutes() / 60 + c.getUTCSeconds() / 3600) / 24); case "g": return c.getHours() % 12 != 0 ? c.getHours() % 12 : 12; case "G": return c.getHours(); case "h": return ("0" + (c.getHours() % 12 != 0 ? c.getHours() % 12 : 12)).replace(/^.+(..)$/, "$1"); case "H": return ("0" + c.getHours()).replace(/^.+(..)$/, "$1"); case "i": return ("0" + c.getMinutes()).replace(/^.+(..)$/, "$1"); case "s": return ("0" + c.getSeconds()).replace(/^.+(..)$/, "$1"); case "u": return c.getMilliseconds(); case "U": return c.getTime() / 1e3 } }) } }(), e.lib.strip_tags = function (e, t) { t = (((t || "") + "").toLowerCase().match(/<[a-z][a-z0-9]*>/g) || []).join(""); var r = /<\/?([a-z][a-z0-9]*)\b[^>]*>/gi, n = /<!--[\s\S]*?-->|<\?(?:php)?[\s\S]*?\?>/gi; return e.replace(n, "").replace(r, function (e, r) { return t.indexOf("<" + r.toLowerCase() + ">") > -1 ? e : "" }) }, e.lib.parseISO8601Date = function (e) { var t = /(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d):(\d\d)(\.\d+)?(Z|([+-])(\d\d):(\d\d))/, r = []; if (!(r = e.match(t))) throw "Couldn't parse ISO 8601 date string '" + e + "'"; var n = [1, 2, 3, 4, 5, 6, 10, 11]; for (var o in n) r[n[o]] = parseInt(r[n[o]], 10); r[7] = parseFloat(r[7]); var i = Date.UTC(r[1], r[2] - 1, r[3], r[4], r[5], r[6]); if (r[7] > 0 && (i += Math.round(1e3 * r[7])), "Z" != r[8] && r[10]) { var s = 60 * r[10] * 60 * 1e3; r[11] && (s += 60 * r[11] * 1e3), "-" == r[9] ? i -= s : i += s } return new Date(i) }, e.lib.strtotime = function (e, t) { function r(e, t, r) { var n, o = a[t]; void 0 !== o && (0 === (n = o - p.getDay()) ? n = 7 * r : n > 0 && "last" === e ? n -= 7 : n < 0 && "next" === e && (n += 7), p.setDate(p.getDate() + n)) } var n, o, i, s, p, a, l, c, u, f, h; if (!e) return !1; if (e = e.replace(/^\s+|\s+$/g, "").replace(/\s{2,}/g, " ").replace(/[\t\r\n]/g, "").toLowerCase(), (o = e.match(/^(\d{1,4})([\-\.\/\:])(\d{1,2})([\-\.\/\:])(\d{1,4})(?:\s(\d{1,2}):(\d{2})?:?(\d{2})?)?(?:\s([A-Z]+)?)?$/)) && o[2] === o[4]) if (o[1] > 1901) switch (o[2]) { case "-": return !(o[3] > 12 || o[5] > 31) && new Date(o[1], parseInt(o[3], 10) - 1, o[5], o[6] || 0, o[7] || 0, o[8] || 0, o[9] || 0) / 1e3; case ".": return !1; case "/": return !(o[3] > 12 || o[5] > 31) && new Date(o[1], parseInt(o[3], 10) - 1, o[5], o[6] || 0, o[7] || 0, o[8] || 0, o[9] || 0) / 1e3 } else if (o[5] > 1901) switch (o[2]) { case "-": case ".": return !(o[3] > 12 || o[1] > 31) && new Date(o[5], parseInt(o[3], 10) - 1, o[1], o[6] || 0, o[7] || 0, o[8] || 0, o[9] || 0) / 1e3; case "/": return !(o[1] > 12 || o[3] > 31) && new Date(o[5], parseInt(o[1], 10) - 1, o[3], o[6] || 0, o[7] || 0, o[8] || 0, o[9] || 0) / 1e3 } else switch (o[2]) { case "-": return !(o[3] > 12 || o[5] > 31 || o[1] < 70 && o[1] > 38) && (s = o[1] >= 0 && o[1] <= 38 ? +o[1] + 2e3 : o[1], new Date(s, parseInt(o[3], 10) - 1, o[5], o[6] || 0, o[7] || 0, o[8] || 0, o[9] || 0) / 1e3); case ".": return o[5] >= 70 ? !(o[3] > 12 || o[1] > 31) && new Date(o[5], parseInt(o[3], 10) - 1, o[1], o[6] || 0, o[7] || 0, o[8] || 0, o[9] || 0) / 1e3 : o[5] < 60 && !o[6] && (!(o[1] > 23 || o[3] > 59) && (i = new Date, new Date(i.getFullYear(), i.getMonth(), i.getDate(), o[1] || 0, o[3] || 0, o[5] || 0, o[9] || 0) / 1e3)); case "/": return !(o[1] > 12 || o[3] > 31 || o[5] < 70 && o[5] > 38) && (s = o[5] >= 0 && o[5] <= 38 ? +o[5] + 2e3 : o[5], new Date(s, parseInt(o[1], 10) - 1, o[3], o[6] || 0, o[7] || 0, o[8] || 0, o[9] || 0) / 1e3); case ":": return !(o[1] > 23 || o[3] > 59 || o[5] > 59) && (i = new Date, new Date(i.getFullYear(), i.getMonth(), i.getDate(), o[1] || 0, o[3] || 0, o[5] || 0) / 1e3) }if ("now" === e) return null === t || isNaN(t) ? (new Date).getTime() / 1e3 | 0 : 0 | t; if (!isNaN(n = Date.parse(e))) return n / 1e3 | 0; if ((o = e.match(/^([0-9]{4}-[0-9]{2}-[0-9]{2})[ t]([0-9]{2}:[0-9]{2}:[0-9]{2}(\.[0-9]+)?)([\+-][0-9]{2}(:[0-9]{2})?|z)/)) && ("z" == o[4] ? o[4] = "Z" : o[4].match(/^([\+-][0-9]{2})$/) && (o[4] = o[4] + ":00"), !isNaN(n = Date.parse(o[1] + "T" + o[2] + o[4])))) return n / 1e3 | 0; if (p = t ? new Date(1e3 * t) : new Date, a = { sun: 0, mon: 1, tue: 2, wed: 3, thu: 4, fri: 5, sat: 6 }, l = { yea: "FullYear", mon: "Month", day: "Date", hou: "Hours", min: "Minutes", sec: "Seconds" }, u = "(years?|months?|weeks?|days?|hours?|minutes?|min|seconds?|sec|sunday|sun\\.?|monday|mon\\.?|tuesday|tue\\.?|wednesday|wed\\.?|thursday|thu\\.?|friday|fri\\.?|saturday|sat\\.?)", f = "([+-]?\\d+\\s" + u + "|(last|next)\\s" + u + ")(\\sago)?", !(o = e.match(new RegExp(f, "gi")))) return !1; for (h = 0, c = o.length; h < c; h++)if (!function (e) { var t = e.split(" "), n = t[0], o = t[1].substring(0, 3), i = /\d+/.test(n), s = "ago" === t[2], a = ("last" === n ? -1 : 1) * (s ? -1 : 1); if (i && (a *= parseInt(n, 10)), l.hasOwnProperty(o) && !t[1].match(/^mon(day|\.)?$/i)) return p["set" + l[o]](p["get" + l[o]]() + a); if ("wee" === o) return p.setDate(p.getDate() + 7 * a); if ("next" === n || "last" === n) r(n, o, a); else if (!i) return !1; return !0 }(o[h])) return !1; return p.getTime() / 1e3 }, e.lib.is = function (e, t) { var r = Object.prototype.toString.call(t).slice(8, -1); return void 0 !== t && null !== t && r === e }, e.lib.copy = function (e) { var t, r = {}; for (t in e) r[t] = e[t]; return r }, e.lib.replaceAll = function (e, t, r) { return e.split(t).join(r) }, e.lib.chunkArray = function (t, r) { var n = [], o = 0, i = t.length; if (r < 1 || !e.lib.is("Array", t)) return []; for (; o < i;)n.push(t.slice(o, o += r)); return n }, e.lib.round = function (e, t, r) { var n, o, i, s; if (t |= 0, n = Math.pow(10, t), e *= n, s = e > 0 | -(e < 0), i = e % 1 == .5 * s, o = Math.floor(e), i) switch (r) { case "PHP_ROUND_HALF_DOWN": e = o + (s < 0); break; case "PHP_ROUND_HALF_EVEN": e = o + o % 2 * s; break; case "PHP_ROUND_HALF_ODD": e = o + !(o % 2); break; default: e = o + (s > 0) }return (i ? e : Math.round(e)) / n }, e.lib.max = function () { var e, t, r = 0, n = 0, o = arguments, i = o.length, s = function (e) { if ("[object Array]" === Object.prototype.toString.call(e)) return e; var t = []; for (var r in e) e.hasOwnProperty(r) && t.push(e[r]); return t }, p = function (e, t) { var r = 0, n = 0, o = 0, i = 0, a = 0; if (e === t) return 0; if ("object" == typeof e) { if ("object" == typeof t) { if (e = s(e), t = s(t), a = e.length, (i = t.length) > a) return 1; if (i < a) return -1; for (r = 0, n = a; r < n; ++r) { if (1 == (o = p(e[r], t[r]))) return 1; if (-1 == o) return -1 } return 0 } return -1 } return "object" == typeof t ? 1 : isNaN(t) && !isNaN(e) ? 0 == e ? 0 : e < 0 ? 1 : -1 : isNaN(e) && !isNaN(t) ? 0 == t ? 0 : t > 0 ? 1 : -1 : t == e ? 0 : t > e ? 1 : -1 }; if (0 === i) throw new Error("At least one value should be passed to max()"); if (1 === i) { if ("object" != typeof o[0]) throw new Error("Wrong parameter count for max()"); if (0 === (e = s(o[0])).length) throw new Error("Array must contain at least one element for max()") } else e = o; for (t = e[0], r = 1, n = e.length; r < n; ++r)1 == p(t, e[r]) && (t = e[r]); return t }, e.lib.min = function () { var e, t, r = 0, n = 0, o = arguments, i = o.length, s = function (e) { if ("[object Array]" === Object.prototype.toString.call(e)) return e; var t = []; for (var r in e) e.hasOwnProperty(r) && t.push(e[r]); return t }, p = function (e, t) { var r = 0, n = 0, o = 0, i = 0, a = 0; if (e === t) return 0; if ("object" == typeof e) { if ("object" == typeof t) { if (e = s(e), t = s(t), a = e.length, (i = t.length) > a) return 1; if (i < a) return -1; for (r = 0, n = a; r < n; ++r) { if (1 == (o = p(e[r], t[r]))) return 1; if (-1 == o) return -1 } return 0 } return -1 } return "object" == typeof t ? 1 : isNaN(t) && !isNaN(e) ? 0 == e ? 0 : e < 0 ? 1 : -1 : isNaN(e) && !isNaN(t) ? 0 == t ? 0 : t > 0 ? 1 : -1 : t == e ? 0 : t > e ? 1 : -1 }; if (0 === i) throw new Error("At least one value should be passed to min()"); if (1 === i) { if ("object" != typeof o[0]) throw new Error("Wrong parameter count for min()"); if (0 === (e = s(o[0])).length) throw new Error("Array must contain at least one element for min()") } else e = o; for (t = e[0], r = 1, n = e.length; r < n; ++r)-1 == p(t, e[r]) && (t = e[r]); return t }, e }(Twig || {})) || {}), Twig = function (e) { "use strict"; e.expression.operator = { leftToRight: "leftToRight", rightToLeft: "rightToLeft" }; var t = function (e, t) { if (void 0 === t || null === t) return null; if (void 0 !== t.indexOf) return e === t || "" !== e && t.indexOf(e) > -1; var r; for (r in t) if (t.hasOwnProperty(r) && t[r] === e) return !0; return !1 }; return e.expression.operator.lookup = function (t, r) { switch (t) { case "..": case "not in": case "in": r.precidence = 20, r.associativity = e.expression.operator.leftToRight; break; case ",": r.precidence = 18, r.associativity = e.expression.operator.leftToRight; break; case "?": case ":": r.precidence = 16, r.associativity = e.expression.operator.rightToLeft; break; case "or": r.precidence = 14, r.associativity = e.expression.operator.leftToRight; break; case "and": r.precidence = 13, r.associativity = e.expression.operator.leftToRight; break; case "==": case "!=": r.precidence = 9, r.associativity = e.expression.operator.leftToRight; break; case "<": case "<=": case ">": case ">=": r.precidence = 8, r.associativity = e.expression.operator.leftToRight; break; case "~": case "+": case "-": r.precidence = 6, r.associativity = e.expression.operator.leftToRight; break; case "//": case "**": case "*": case "/": case "%": r.precidence = 5, r.associativity = e.expression.operator.leftToRight; break; case "not": r.precidence = 3, r.associativity = e.expression.operator.rightToLeft; break; default: throw new e.Error(t + " is an unknown operator.") }return r.operator = t, r }, e.expression.operator.parse = function (r, n) { e.log.trace("Twig.expression.operator.parse: ", "Handling ", r); var o, i, s; switch (r) { case ":": break; case "?": s = n.pop(), i = n.pop(), (o = n.pop()) ? n.push(i) : n.push(s); break; case "+": i = parseFloat(n.pop()), o = parseFloat(n.pop()), n.push(o + i); break; case "-": i = parseFloat(n.pop()), o = parseFloat(n.pop()), n.push(o - i); break; case "*": i = parseFloat(n.pop()), o = parseFloat(n.pop()), n.push(o * i); break; case "/": i = parseFloat(n.pop()), o = parseFloat(n.pop()), n.push(o / i); break; case "//": i = parseFloat(n.pop()), o = parseFloat(n.pop()), n.push(parseInt(o / i)); break; case "%": i = parseFloat(n.pop()), o = parseFloat(n.pop()), n.push(o % i); break; case "~": i = n.pop(), o = n.pop(), n.push((null != o ? o.toString() : "") + (null != i ? i.toString() : "")); break; case "not": case "!": n.push(!n.pop()); break; case "<": i = n.pop(), o = n.pop(), n.push(o < i); break; case "<=": i = n.pop(), o = n.pop(), n.push(o <= i); break; case ">": i = n.pop(), o = n.pop(), n.push(o > i); break; case ">=": i = n.pop(), o = n.pop(), n.push(o >= i); break; case "===": i = n.pop(), o = n.pop(), n.push(o === i); break; case "==": i = n.pop(), o = n.pop(), n.push(o == i); break; case "!==": i = n.pop(), o = n.pop(), n.push(o !== i); break; case "!=": i = n.pop(), o = n.pop(), n.push(o != i); break; case "or": i = n.pop(), o = n.pop(), n.push(o || i); break; case "and": i = n.pop(), o = n.pop(), n.push(o && i); break; case "**": i = n.pop(), o = n.pop(), n.push(Math.pow(o, i)); break; case "not in": i = n.pop(), o = n.pop(), n.push(!t(o, i)); break; case "in": i = n.pop(), o = n.pop(), n.push(t(o, i)); break; case "..": i = n.pop(), o = n.pop(), n.push(e.functions.range(o, i)); break; default: throw new e.Error(r + " is an unknown operator.") } }, e }((Twig = function (e) { "use strict"; e.expression = {}, e.expression.reservedWords = ["true", "false", "null", "TRUE", "FALSE", "NULL", "_context"], e.expression.type = { comma: "Twig.expression.type.comma", operator: { unary: "Twig.expression.type.operator.unary", binary: "Twig.expression.type.operator.binary" }, string: "Twig.expression.type.string", bool: "Twig.expression.type.bool", array: { start: "Twig.expression.type.array.start", end: "Twig.expression.type.array.end" }, object: { start: "Twig.expression.type.object.start", end: "Twig.expression.type.object.end" }, parameter: { start: "Twig.expression.type.parameter.start", end: "Twig.expression.type.parameter.end" }, key: { period: "Twig.expression.type.key.period", brackets: "Twig.expression.type.key.brackets" }, filter: "Twig.expression.type.filter", _function: "Twig.expression.type._function", variable: "Twig.expression.type.variable", number: "Twig.expression.type.number", _null: "Twig.expression.type.null", context: "Twig.expression.type.context", test: "Twig.expression.type.test" }, e.expression.set = { operations: [e.expression.type.filter, e.expression.type.operator.unary, e.expression.type.operator.binary, e.expression.type.array.end, e.expression.type.object.end, e.expression.type.parameter.end, e.expression.type.comma, e.expression.type.test], expressions: [e.expression.type._function, e.expression.type.bool, e.expression.type.string, e.expression.type.variable, e.expression.type.number, e.expression.type._null, e.expression.type.context, e.expression.type.parameter.start, e.expression.type.array.start, e.expression.type.object.start] }, e.expression.set.operations_extended = e.expression.set.operations.concat([e.expression.type.key.period, e.expression.type.key.brackets]), e.expression.fn = { compile: { push: function (e, t, r) { r.push(e) }, push_both: function (e, t, r) { r.push(e), t.push(e) } }, parse: { push: function (e, t, r) { t.push(e) }, push_value: function (e, t, r) { t.push(e.value) } } }, e.expression.definitions = [{ type: e.expression.type.test, regex: /^is\s+(not)?\s*([a-zA-Z_][a-zA-Z0-9_]*)/, next: e.expression.set.operations.concat([e.expression.type.parameter.start]), compile: function (e, t, r) { e.filter = e.match[2], e.modifier = e.match[1], delete e.match, delete e.value, r.push(e) }, parse: function (t, r, n) { var o = r.pop(), i = t.params && e.expression.parse.apply(this, [t.params, n]), s = e.test(t.filter, o, i); "not" == t.modifier ? r.push(!s) : r.push(s) } }, { type: e.expression.type.comma, regex: /^,/, next: e.expression.set.expressions.concat([e.expression.type.array.end, e.expression.type.object.end]), compile: function (t, r, n) { var o, i = r.length - 1; for (delete t.match, delete t.value; i >= 0; i--) { if ((o = r.pop()).type === e.expression.type.object.start || o.type === e.expression.type.parameter.start || o.type === e.expression.type.array.start) { r.push(o); break } n.push(o) } n.push(t) } }, { type: e.expression.type.operator.binary, regex: /(^[\+\-~%\?\:]|^[!=]==?|^[!<>]=?|^\*\*?|^\/\/?|^and\s+|^or\s+|^in\s+|^not in\s+|^\.\.)/, next: e.expression.set.expressions.concat([e.expression.type.operator.unary]), compile: function (t, r, n) { delete t.match, t.value = t.value.trim(); var o = t.value, i = e.expression.operator.lookup(o, t); for (e.log.trace("Twig.expression.compile: ", "Operator: ", i, " from ", o); r.length > 0 && (r[r.length - 1].type == e.expression.type.operator.unary || r[r.length - 1].type == e.expression.type.operator.binary) && (i.associativity === e.expression.operator.leftToRight && i.precidence >= r[r.length - 1].precidence || i.associativity === e.expression.operator.rightToLeft && i.precidence > r[r.length - 1].precidence);) { var s = r.pop(); n.push(s) } if (":" === o) { if (!r[r.length - 1] || "?" !== r[r.length - 1].value) { var p = n.pop(); if (p.type === e.expression.type.string || p.type === e.expression.type.variable) t.key = p.value; else if (p.type === e.expression.type.number) t.key = p.value.toString(); else { if (p.type !== e.expression.type.parameter.end || !p.expression) throw new e.Error("Unexpected value before ':' of " + p.type + " = " + p.value); t.params = p.params } return void n.push(t) } } else r.push(i) }, parse: function (t, r, n) { t.key ? r.push(t) : t.params ? (t.key = e.expression.parse.apply(this, [t.params, n]), r.push(t), delete t.params) : e.expression.operator.parse(t.value, r) } }, { type: e.expression.type.operator.unary, regex: /(^not\s+)/, next: e.expression.set.expressions, compile: function (t, r, n) { delete t.match, t.value = t.value.trim(); var o = t.value, i = e.expression.operator.lookup(o, t); for (e.log.trace("Twig.expression.compile: ", "Operator: ", i, " from ", o); r.length > 0 && (r[r.length - 1].type == e.expression.type.operator.unary || r[r.length - 1].type == e.expression.type.operator.binary) && (i.associativity === e.expression.operator.leftToRight && i.precidence >= r[r.length - 1].precidence || i.associativity === e.expression.operator.rightToLeft && i.precidence > r[r.length - 1].precidence);) { var s = r.pop(); n.push(s) } r.push(i) }, parse: function (t, r, n) { e.expression.operator.parse(t.value, r) } }, { type: e.expression.type.string, regex: /^(["'])(?:(?=(\\?))\2[\s\S])*?\1/, next: e.expression.set.operations, compile: function (t, r, n) { var o = t.value; delete t.match, o = '"' === o.substring(0, 1) ? o.replace('\\"', '"') : o.replace("\\'", "'"), t.value = o.substring(1, o.length - 1).replace(/\\n/g, "\n").replace(/\\r/g, "\r"), e.log.trace("Twig.expression.compile: ", "String value: ", t.value), n.push(t) }, parse: e.expression.fn.parse.push_value }, { type: e.expression.type.parameter.start, regex: /^\(/, next: e.expression.set.expressions.concat([e.expression.type.parameter.end]), compile: e.expression.fn.compile.push_both, parse: e.expression.fn.parse.push }, { type: e.expression.type.parameter.end, regex: /^\)/, next: e.expression.set.operations_extended, compile: function (t, r, n) { var o, i = t; for (o = r.pop(); r.length > 0 && o.type != e.expression.type.parameter.start;)n.push(o), o = r.pop(); for (var s = []; t.type !== e.expression.type.parameter.start;)s.unshift(t), t = n.pop(); s.unshift(t); void 0 === (t = n[n.length - 1]) || t.type !== e.expression.type._function && t.type !== e.expression.type.filter && t.type !== e.expression.type.test && t.type !== e.expression.type.key.brackets && t.type !== e.expression.type.key.period ? (i.expression = !0, s.pop(), s.shift(), i.params = s, n.push(i)) : (i.expression = !1, t.params = s) }, parse: function (t, r, n) { var o = [], i = !1, s = null; if (t.expression) s = e.expression.parse.apply(this, [t.params, n]), r.push(s); else { for (; r.length > 0;) { if ((s = r.pop()) && s.type && s.type == e.expression.type.parameter.start) { i = !0; break } o.unshift(s) } if (!i) throw new e.Error("Expected end of parameter set."); r.push(o) } } }, { type: e.expression.type.array.start, regex: /^\[/, next: e.expression.set.expressions.concat([e.expression.type.array.end]), compile: e.expression.fn.compile.push_both, parse: e.expression.fn.parse.push }, { type: e.expression.type.array.end, regex: /^\]/, next: e.expression.set.operations_extended, compile: function (t, r, n) { for (var o, i = r.length - 1; i >= 0 && (o = r.pop()).type !== e.expression.type.array.start; i--)n.push(o); n.push(t) }, parse: function (t, r, n) { for (var o = [], i = !1, s = null; r.length > 0;) { if ((s = r.pop()).type && s.type == e.expression.type.array.start) { i = !0; break } o.unshift(s) } if (!i) throw new e.Error("Expected end of array."); r.push(o) } }, { type: e.expression.type.object.start, regex: /^\{/, next: e.expression.set.expressions.concat([e.expression.type.object.end]), compile: e.expression.fn.compile.push_both, parse: e.expression.fn.parse.push }, { type: e.expression.type.object.end, regex: /^\}/, next: e.expression.set.operations_extended, compile: function (t, r, n) { for (var o, i = r.length - 1; i >= 0 && (!(o = r.pop()) || o.type !== e.expression.type.object.start); i--)n.push(o); n.push(t) }, parse: function (t, r, n) { for (var o = {}, i = !1, s = null, p = !1, a = null; r.length > 0;) { if ((s = r.pop()) && s.type && s.type === e.expression.type.object.start) { i = !0; break } if (s && s.type && (s.type === e.expression.type.operator.binary || s.type === e.expression.type.operator.unary) && s.key) { if (!p) throw new e.Error("Missing value for key '" + s.key + "' in object definition."); o[s.key] = a, void 0 === o._keys && (o._keys = []), o._keys.unshift(s.key), a = null, p = !1 } else p = !0, a = s } if (!i) throw new e.Error("Unexpected end of object."); r.push(o) } }, { type: e.expression.type.filter, regex: /^\|\s?([a-zA-Z_][a-zA-Z0-9_\-]*)/, next: e.expression.set.operations_extended.concat([e.expression.type.parameter.start]), compile: function (e, t, r) { e.value = e.match[1], r.push(e) }, parse: function (t, r, n) { var o = r.pop(), i = t.params && e.expression.parse.apply(this, [t.params, n]); r.push(e.filter.apply(this, [t.value, o, i])) } }, { type: e.expression.type._function, regex: /^([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/, next: e.expression.type.parameter.start, transform: function (e, t) { return "(" }, compile: function (e, t, r) { var n = e.match[1]; e.fn = n, delete e.match, delete e.value, r.push(e) }, parse: function (t, r, n) { var o, i = t.params && e.expression.parse.apply(this, [t.params, n]), s = t.fn; if (e.functions[s]) o = e.functions[s].apply(this, i); else { if ("function" != typeof n[s]) throw new e.Error(s + " function does not exist and is not defined in the context"); o = n[s].apply(n, i) } r.push(o) } }, { type: e.expression.type.variable, regex: /^[a-zA-Z_][a-zA-Z0-9_]*/, next: e.expression.set.operations_extended.concat([e.expression.type.parameter.start]), compile: e.expression.fn.compile.push, validate: function (t, r) { return e.indexOf(e.expression.reservedWords, t[0]) < 0 }, parse: function (t, r, n) { var o = e.expression.resolve(n[t.value], n); r.push(o) } }, { type: e.expression.type.key.period, regex: /^\.([a-zA-Z0-9_]+)/, next: e.expression.set.operations_extended.concat([e.expression.type.parameter.start]), compile: function (e, t, r) { e.key = e.match[1], delete e.match, delete e.value, r.push(e) }, parse: function (t, r, n) { var o, i = t.params && e.expression.parse.apply(this, [t.params, n]), s = t.key, p = r.pop(); if (null === p || void 0 === p) { if (this.options.strict_variables) throw new e.Error("Can't access a key " + s + " on an null or undefined object."); return null } var a = function (e) { return e.substr(0, 1).toUpperCase() + e.substr(1) }; o = "object" == typeof p && s in p ? p[s] : void 0 !== p["get" + a(s)] ? p["get" + a(s)] : void 0 !== p["is" + a(s)] ? p["is" + a(s)] : void 0, r.push(e.expression.resolve(o, p, i)) } }, { type: e.expression.type.key.brackets, regex: /^\[([^\]]*)\]/, next: e.expression.set.operations_extended.concat([e.expression.type.parameter.start]), compile: function (t, r, n) { var o = t.match[1]; delete t.value, delete t.match, t.stack = e.expression.compile({ value: o }).stack, n.push(t) }, parse: function (t, r, n) { var o, i = t.params && e.expression.parse.apply(this, [t.params, n]), s = e.expression.parse.apply(this, [t.stack, n]), p = r.pop(); if (null === p || void 0 === p) { if (this.options.strict_variables) throw new e.Error("Can't access a key " + s + " on an null or undefined object."); return null } o = "object" == typeof p && s in p ? p[s] : null, r.push(e.expression.resolve(o, p, i)) } }, { type: e.expression.type._null, regex: /^(null|NULL|none|NONE)/, next: e.expression.set.operations, compile: function (e, t, r) { delete e.match, e.value = null, r.push(e) }, parse: e.expression.fn.parse.push_value }, { type: e.expression.type.context, regex: /^_context/, next: e.expression.set.operations_extended.concat([e.expression.type.parameter.start]), compile: e.expression.fn.compile.push, parse: function (e, t, r) { t.push(r) } }, { type: e.expression.type.number, regex: /^\-?\d+(\.\d+)?/, next: e.expression.set.operations, compile: function (e, t, r) { e.value = Number(e.value), r.push(e) }, parse: e.expression.fn.parse.push_value }, { type: e.expression.type.bool, regex: /^(true|TRUE|false|FALSE)/, next: e.expression.set.operations, compile: function (e, t, r) { e.value = "true" === e.match[0].toLowerCase(), delete e.match, r.push(e) }, parse: e.expression.fn.parse.push_value }], e.expression.resolve = function (e, t, r) { return "function" == typeof e ? e.apply(t, r || []) : e }, e.expression.handler = {}, e.expression.extendType = function (t) { e.expression.type[t] = "Twig.expression.type." + t }, e.expression.extend = function (t) { if (!t.type) throw new e.Error("Unable to extend logic definition. No type provided for " + t); e.expression.handler[t.type] = t }; for (; e.expression.definitions.length > 0;)e.expression.extend(e.expression.definitions.shift()); return e.expression.tokenize = function (t) { var r, n, o, i, s, p, a = [], l = 0, c = null, u = []; for (p = function () { var t = Array.prototype.slice.apply(arguments); t.pop(), t.pop(); return e.log.trace("Twig.expression.tokenize", "Matched a ", r, " regular expression of ", t), c && e.indexOf(c, r) < 0 ? (u.push(r + " cannot follow a " + a[a.length - 1].type + " at template:" + l + " near '" + t[0].substring(0, 20) + "...'"), t[0]) : e.expression.handler[r].validate && !e.expression.handler[r].validate(t, a) ? t[0] : (u = [], a.push({ type: r, value: t[0], match: t }), s = !0, c = i, l += t[0].length, e.expression.handler[r].transform ? e.expression.handler[r].transform(t, a) : "") }, e.log.debug("Twig.expression.tokenize", "Tokenizing expression ", t); t.length > 0;) { t = t.trim(); for (r in e.expression.handler) if (e.expression.handler.hasOwnProperty(r)) { for (i = e.expression.handler[r].next, o = (n = e.expression.handler[r].regex) instanceof Array ? n : [n], s = !1; o.length > 0;)n = o.pop(), t = t.replace(n, p); if (s) break } if (!s) throw u.length > 0 ? new e.Error(u.join(" OR ")) : new e.Error("Unable to parse '" + t + "' at template position" + l) } return e.log.trace("Twig.expression.tokenize", "Tokenized to ", a), a }, e.expression.compile = function (t) { var r = t.value, n = e.expression.tokenize(r), o = null, i = [], s = [], p = null; for (e.log.trace("Twig.expression.compile: ", "Compiling ", r); n.length > 0;)o = n.shift(), p = e.expression.handler[o.type], e.log.trace("Twig.expression.compile: ", "Compiling ", o), p.compile && p.compile(o, s, i), e.log.trace("Twig.expression.compile: ", "Stack is", s), e.log.trace("Twig.expression.compile: ", "Output is", i); for (; s.length > 0;)i.push(s.pop()); return e.log.trace("Twig.expression.compile: ", "Final output is", i), t.stack = i, delete t.value, t }, e.expression.parse = function (t, r) { var n = this; t instanceof Array || (t = [t]); var o = [], i = null; return e.forEach(t, function (t) { (i = e.expression.handler[t.type]).parse && i.parse.apply(n, [t, o, r]) }), o.pop() }, e }(Twig || {})) || {}), Twig = function (e) { return e.functions = { range: function (e, t, r) { var n, o, i = [], s = r || 1, p = !1; if (isNaN(e) || isNaN(t) ? isNaN(e) && isNaN(t) ? (p = !0, n = e.charCodeAt(0), o = t.charCodeAt(0)) : (n = isNaN(e) ? 0 : e, o = isNaN(t) ? 0 : t) : (n = parseInt(e, 10), o = parseInt(t, 10)), !(n > o)) for (; n <= o;)i.push(p ? String.fromCharCode(n) : n), n += s; else for (; n >= o;)i.push(p ? String.fromCharCode(n) : n), n -= s; return i }, cycle: function (e, t) { return e[t % e.length] }, dump: function () { var t = 0, r = "", n = Array.prototype.slice.call(arguments), o = function (e) { for (var t = ""; e > 0;)e-- , t += "  "; return t }, i = function (e) { r += o(t), "object" == typeof e ? s(e) : "function" == typeof e ? r += "function()\n" : "string" == typeof e ? r += "string(" + e.length + ') "' + e + '"\n' : "number" == typeof e ? r += "number(" + e + ")\n" : "boolean" == typeof e && (r += "bool(" + e + ")\n") }, s = function (e) { var n; if (null === e) r += "NULL\n"; else if (void 0 === e) r += "undefined\n"; else if ("object" == typeof e) { r += o(t) + typeof e, t++ , r += "(" + function (e) { var t, r = 0; for (t in e) e.hasOwnProperty(t) && r++; return r }(e) + ") {\n"; for (n in e) r += o(t) + "[" + n + "]=> \n", i(e[n]); r += o(--t) + "}\n" } else i(e) }; return 0 == n.length && n.push(this.context), e.forEach(n, function (e) { s(e) }), r }, date: function (t, r) { var n; if (void 0 === t) n = new Date; else if (e.lib.is("Date", t)) n = t; else if (e.lib.is("String", t)) n = t.match(/^[0-9]+$/) ? new Date(1e3 * t) : new Date(1e3 * e.lib.strtotime(t)); else { if (!e.lib.is("Number", t)) throw new e.Error("Unable to parse date " + t); n = new Date(1e3 * t) } return n }, block: function (t) { return this.originalBlockTokens[t] ? e.logic.parse.apply(this, [this.originalBlockTokens[t], this.context]).output : this.blocks[t] }, parent: function () { return e.placeholders.parent }, attribute: function (t, r, n) { return e.lib.is("Object", t) && t.hasOwnProperty(r) ? "function" == typeof t[r] ? t[r].apply(void 0, n) : t[r] : t[r] || void 0 }, max: function (t) { return e.lib.is("Object", t) ? (delete t._keys, e.lib.max(t)) : e.lib.max.apply(null, arguments) }, min: function (t) { return e.lib.is("Object", t) ? (delete t._keys, e.lib.min(t)) : e.lib.min.apply(null, arguments) }, template_from_string: function (t) { return void 0 === t && (t = ""), e.Templates.parsers.twig({ options: this.options, data: t }) }, random: function (t) { function r(e) { var t = Math.floor(Math.random() * n), r = [0, e], o = Math.min.apply(null, r), i = Math.max.apply(null, r); return o + Math.floor((i - o + 1) * t / n) } var n = 2147483648; if (e.lib.is("Number", t)) return r(t); if (e.lib.is("String", t)) return t.charAt(r(t.length - 1)); if (e.lib.is("Array", t)) return t[r(t.length - 1)]; if (e.lib.is("Object", t)) { var o = Object.keys(t); return t[o[r(o.length - 1)]] } return r(n - 1) }, source: function (t, r) { var n, o, i, s = !1; "undefined" != typeof module && void 0 !== module.exports && "undefined" == typeof window ? (o = "fs", i = __dirname + "/" + t) : (o = "ajax", i = t); var p = { id: t, path: i, method: o, parser: "source", async: !1, fetchTemplateSource: !0 }; void 0 === r && (r = !1); try { void 0 === (n = e.Templates.loadRemote(t, p)) || null === n ? n = "" : s = !0 } catch (t) { e.log.debug("Twig.functions.source: ", "Problem loading template  ", t) } return s || r ? n : 'Template "{name}" is not defined.'.replace("{name}", t) } }, e._function = function (t, r, n) { if (!e.functions[t]) throw "Unable to find function " + t; return e.functions[t](r, n) }, e._function.extend = function (t, r) { e.functions[t] = r }, e }((Twig = function (e) { function t(e, t) { var r = Object.prototype.toString.call(t).slice(8, -1); return void 0 !== t && null !== t && r === e } return e.filters = { upper: function (e) { return "string" != typeof e ? e : e.toUpperCase() }, lower: function (e) { return "string" != typeof e ? e : e.toLowerCase() }, capitalize: function (e) { return "string" != typeof e ? e : e.substr(0, 1).toUpperCase() + e.toLowerCase().substr(1) }, title: function (e) { return "string" != typeof e ? e : e.toLowerCase().replace(/(^|\s)([a-z])/g, function (e, t, r) { return t + r.toUpperCase() }) }, length: function (t) { return e.lib.is("Array", t) || "string" == typeof t ? t.length : e.lib.is("Object", t) ? void 0 === t._keys ? Object.keys(t).length : t._keys.length : 0 }, reverse: function (e) { if (t("Array", e)) return e.reverse(); if (t("String", e)) return e.split("").reverse().join(""); if (t("Object", e)) { var r = e._keys || Object.keys(e).reverse(); return e._keys = r, e } }, sort: function (e) { if (t("Array", e)) return e.sort(); if (t("Object", e)) { delete e._keys; var r = Object.keys(e).sort(function (t, r) { var n; return e[t] > e[r] == !(e[t] <= e[r]) ? e[t] > e[r] ? 1 : e[t] < e[r] ? -1 : 0 : isNaN(n = parseFloat(e[t])) || isNaN(b1 = parseFloat(e[r])) ? "string" == typeof e[t] ? e[t] > e[r].toString() ? 1 : e[t] < e[r].toString() ? -1 : 0 : "string" == typeof e[r] ? e[t].toString() > e[r] ? 1 : e[t].toString() < e[r] ? -1 : 0 : null : n > b1 ? 1 : n < b1 ? -1 : 0 }); return e._keys = r, e } }, keys: function (t) { if (void 0 !== t && null !== t) { var r = t._keys || Object.keys(t), n = []; return e.forEach(r, function (e) { "_keys" !== e && t.hasOwnProperty(e) && n.push(e) }), n } }, url_encode: function (e) { if (void 0 !== e && null !== e) { var t = encodeURIComponent(e); return t = t.replace("'", "%27") } }, join: function (r, n) { if (void 0 !== r && null !== r) { var o = "", i = [], s = null; return n && n[0] && (o = n[0]), t("Array", r) ? i = r : (s = r._keys || Object.keys(r), e.forEach(s, function (e) { "_keys" !== e && r.hasOwnProperty(e) && i.push(r[e]) })), i.join(o) } }, default: function (t, r) { if (void 0 !== r && r.length > 1) throw new e.Error("default filter expects one argument"); return void 0 === t || null === t || "" === t ? void 0 === r ? "" : r[0] : t }, json_encode: function (r) { if (void 0 === r || null === r) return "null"; if ("object" == typeof r && t("Array", r)) return o = [], e.forEach(r, function (t) { o.push(e.filters.json_encode(t)) }), "[" + o.join(",") + "]"; if ("object" == typeof r) { var n = r._keys || Object.keys(r), o = []; return e.forEach(n, function (t) { o.push(JSON.stringify(t) + ":" + e.filters.json_encode(r[t])) }), "{" + o.join(",") + "}" } return JSON.stringify(r) }, merge: function (r, n) { var o = [], i = 0, s = []; if (t("Array", r) ? e.forEach(n, function (e) { t("Array", e) || (o = {}) }) : o = {}, t("Array", o) || (o._keys = []), t("Array", r) ? e.forEach(r, function (e) { o._keys && o._keys.push(i), o[i] = e, i++ }) : (s = r._keys || Object.keys(r), e.forEach(s, function (e) { o[e] = r[e], o._keys.push(e); var t = parseInt(e, 10); !isNaN(t) && t >= i && (i = t + 1) })), e.forEach(n, function (r) { t("Array", r) ? e.forEach(r, function (e) { o._keys && o._keys.push(i), o[i] = e, i++ }) : (s = r._keys || Object.keys(r), e.forEach(s, function (e) { o[e] || o._keys.push(e), o[e] = r[e]; var t = parseInt(e, 10); !isNaN(t) && t >= i && (i = t + 1) })) }), 0 === n.length) throw new e.Error("Filter merge expects at least one parameter"); return o }, date: function (t, r) { var n = e.functions.date(t), o = r && r.length ? r[0] : "F j, Y H:i"; return e.lib.formatDate(n, o) }, date_modify: function (t, r) { if (void 0 !== t && null !== t) { if (void 0 === r || 1 !== r.length) throw new e.Error("date_modify filter expects 1 argument"); var n, o = r[0]; return e.lib.is("Date", t) && (n = e.lib.strtotime(o, t.getTime() / 1e3)), e.lib.is("String", t) && (n = e.lib.strtotime(o, e.lib.strtotime(t))), e.lib.is("Number", t) && (n = e.lib.strtotime(o, t)), new Date(1e3 * n) } }, replace: function (t, r) { if (void 0 !== t && null !== t) { var n, o = r[0]; for (n in o) o.hasOwnProperty(n) && "_keys" !== n && (t = e.lib.replaceAll(t, n, o[n])); return t } }, format: function (t, r) { if (void 0 !== t && null !== t) return e.lib.vsprintf(t, r) }, striptags: function (t) { if (void 0 !== t && null !== t) return e.lib.strip_tags(t) }, escape: function (t, r) { if (void 0 !== t && null !== t) { var n = "html"; if (r && r.length && !0 !== r[0] && (n = r[0]), "html" == n) { o = t.toString().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"); return e.Markup(o, "html") } if ("js" == n) { for (var o = t.toString(), i = "", s = 0; s < o.length; s++)o[s].match(/^[a-zA-Z0-9,\._]$/) ? i += o[s] : i += (p = o.charCodeAt(s)) < 128 ? "\\x" + p.toString(16).toUpperCase() : e.lib.sprintf("\\u%04s", p.toString(16).toUpperCase()); return e.Markup(i, "js") } if ("css" == n) { for (var o = t.toString(), i = "", s = 0; s < o.length; s++)o[s].match(/^[a-zA-Z0-9]$/) ? i += o[s] : i += "\\" + (p = o.charCodeAt(s)).toString(16).toUpperCase() + " "; return e.Markup(i, "css") } if ("url" == n) { i = e.filters.url_encode(t); return e.Markup(i, "url") } if ("html_attr" == n) { for (var o = t.toString(), i = "", s = 0; s < o.length; s++)if (o[s].match(/^[a-zA-Z0-9,\.\-_]$/)) i += o[s]; else if (o[s].match(/^[&<>"]$/)) i += o[s].replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;"); else { var p = o.charCodeAt(s); i += p <= 31 && 9 != p && 10 != p && 13 != p ? "&#xFFFD;" : p < 128 ? e.lib.sprintf("&#x%02s;", p.toString(16).toUpperCase()) : e.lib.sprintf("&#x%04s;", p.toString(16).toUpperCase()) } return e.Markup(i, "html_attr") } throw new e.Error("escape strategy unsupported") } }, e: function (t, r) { return e.filters.escape(t, r) }, nl2br: function (t) { if (void 0 !== t && null !== t) { var r = "<br />BACKSLASH_n_replace"; return t = e.filters.escape(t).replace(/\r\n/g, r).replace(/\r/g, r).replace(/\n/g, r), t = e.lib.replaceAll(t, "BACKSLASH_n_replace", "\n"), e.Markup(t) } }, number_format: function (e, t) { var r = e, n = t && t[0] ? t[0] : void 0, o = t && void 0 !== t[1] ? t[1] : ".", i = t && void 0 !== t[2] ? t[2] : ","; r = (r + "").replace(/[^0-9+\-Ee.]/g, ""); var s = isFinite(+r) ? +r : 0, p = isFinite(+n) ? Math.abs(n) : 0, a = ""; return (a = (p ? function (e, t) { var r = Math.pow(10, t); return "" + Math.round(e * r) / r }(s, p) : "" + Math.round(s)).split("."))[0].length > 3 && (a[0] = a[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, i)), (a[1] || "").length < p && (a[1] = a[1] || "", a[1] += new Array(p - a[1].length + 1).join("0")), a.join(o) }, trim: function (t, r) { if (void 0 !== t && null !== t) { var n, o = e.filters.escape("" + t); n = r && r[0] ? "" + r[0] : " \n\r\t\f\v\u2028\u2029"; for (var i = 0; i < o.length; i++)if (-1 === n.indexOf(o.charAt(i))) { o = o.substring(i); break } for (i = o.length - 1; i >= 0; i--)if (-1 === n.indexOf(o.charAt(i))) { o = o.substring(0, i + 1); break } return -1 === n.indexOf(o.charAt(0)) ? o : "" } }, truncate: function (e, t) { var r = 30, n = !1, o = "..."; if (e += "", t && (t[0] && (r = t[0]), t[1] && (n = t[1]), t[2] && (o = t[2])), e.length > r) { if (n && -1 === (r = e.indexOf(" ", r))) return e; e = e.substr(0, r) + o } return e }, slice: function (t, r) { if (void 0 !== t && null !== t) { if (void 0 === r || r.length < 1) throw new e.Error("slice filter expects at least 1 argument"); var n = r[0] || 0, o = r.length > 1 ? r[1] : t.length, i = n >= 0 ? n : Math.max(t.length + n, 0); if (e.lib.is("Array", t)) { for (var s = [], p = i; p < i + o && p < t.length; p++)s.push(t[p]); return s } if (e.lib.is("String", t)) return t.substr(i, o); throw new e.Error("slice filter expects value to be an array or string") } }, abs: function (e) { if (void 0 !== e && null !== e) return Math.abs(e) }, first: function (e) { if (t("Array", e)) return e[0]; if (t("Object", e)) { if ("_keys" in e) return e[e._keys[0]] } else if ("string" == typeof e) return e.substr(0, 1) }, split: function (t, r) { if (void 0 !== t && null !== t) { if (void 0 === r || r.length < 1 || r.length > 2) throw new e.Error("split filter expects 1 or 2 argument"); if (e.lib.is("String", t)) { var n = r[0], o = r[1], i = t.split(n); if (void 0 === o) return i; if (o < 0) return t.split(n, i.length + o); var s = []; if ("" == n) for (; i.length > 0;) { for (var p = "", a = 0; a < o && i.length > 0; a++)p += i.shift(); s.push(p) } else { for (a = 0; a < o - 1 && i.length > 0; a++)s.push(i.shift()); i.length > 0 && s.push(i.join(n)) } return s } throw new e.Error("split filter expects value to be a string") } }, last: function (t) { if (e.lib.is("Object", t)) { var r; return r = void 0 === t._keys ? Object.keys(t) : t._keys, t[r[r.length - 1]] } return t[t.length - 1] }, raw: function (t) { return e.Markup(t) }, batch: function (t, r) { var n, o, i, s = r.shift(), p = r.shift(); if (!e.lib.is("Array", t)) throw new e.Error("batch filter expects items to be an array"); if (!e.lib.is("Number", s)) throw new e.Error("batch filter expects size to be a number"); if (s = Math.ceil(s), n = e.lib.chunkArray(t, s), p && t.length % s != 0) { for (i = s - (o = n.pop()).length; i--;)o.push(p); n.push(o) } return n }, round: function (t, r) { var n = (r = r || []).length > 0 ? r[0] : 0, o = r.length > 1 ? r[1] : "common"; if (t = parseFloat(t), n && !e.lib.is("Number", n)) throw new e.Error("round filter expects precision to be a number"); if ("common" === o) return e.lib.round(t, n); if (!e.lib.is("Function", Math[o])) throw new e.Error("round filter expects method to be 'floor', 'ceil', or 'common'"); return Math[o](t * Math.pow(10, n)) / Math.pow(10, n) } }, e.filter = function (t, r, n) { if (!e.filters[t]) throw "Unable to find filter " + t; return e.filters[t].apply(this, [r, n]) }, e.filter.extend = function (t, r) { e.filters[t] = r }, e }(Twig || {})) || {}), Twig = function (e) { "use strict"; return e.tests = { empty: function (e) { if (null === e || void 0 === e) return !0; if ("number" == typeof e) return !1; if (e.length && e.length > 0) return !1; for (var t in e) if (e.hasOwnProperty(t)) return !1; return !0 }, odd: function (e) { return e % 2 == 1 }, even: function (e) { return e % 2 == 0 }, divisibleby: function (e, t) { return e % t[0] == 0 }, defined: function (e) { return void 0 !== e }, none: function (e) { return null === e }, null: function (e) { return this.none(e) }, sameas: function (e, t) { return e === t[0] }, iterable: function (t) { return t && (e.lib.is("Array", t) || e.lib.is("Object", t)) } }, e.test = function (t, r, n) { if (!e.tests[t]) throw "Test " + t + " is not defined."; return e.tests[t](r, n) }, e.test.extend = function (t, r) { e.tests[t] = r }, e }((Twig = function (e) { "use strict"; return e.path = {}, e.path.parsePath = function (t, r) { var n = null, r = r || ""; if ("object" == typeof t && "object" == typeof t.options && (n = t.options.namespaces), "object" == typeof n && r.indexOf("::") > 0 || r.indexOf("@") >= 0) { for (var o in n) n.hasOwnProperty(o) && (r = (r = r.replace(o + "::", n[o])).replace("@" + o, n[o])); return r } return e.path.relativePath(t, r) }, e.path.relativePath = function (t, r) { var n, o, i, s = "/", p = [], r = r || ""; if (t.url) n = void 0 !== t.base ? t.base + ("/" === t.base.charAt(t.base.length - 1) ? "" : "/") : t.url; else if (t.path) { var a = require("path"), l = a.sep || s, c = new RegExp("^\\.{1,2}" + l.replace("\\", "\\\\")); r = r.replace(/\//g, l), void 0 !== t.base && null == r.match(c) ? (r = r.replace(t.base, ""), n = t.base + l) : n = a.normalize(t.path), n = n.replace(l + l, l), s = l } else { if (!t.name && !t.id || !t.method || "fs" === t.method || "ajax" === t.method) throw new e.Error("Cannot extend an inline template."); n = t.base || t.name || t.id } for ((o = n.split(s)).pop(), o = o.concat(r.split(s)); o.length > 0;)"." == (i = o.shift()) || (".." == i && p.length > 0 && ".." != p[p.length - 1] ? p.pop() : p.push(i)); return p.join(s) }, e }(Twig || {})) || {}), Twig = function (e) { return e.compiler = { module: {} }, e.compiler.compile = function (t, r) { var n, o = JSON.stringify(t.tokens), i = t.id; if (r.module) { if (void 0 === e.compiler.module[r.module]) throw new e.Error("Unable to find module type " + r.module); n = e.compiler.module[r.module](i, o, r.twig) } else n = e.compiler.wrap(i, o); return n }, e.compiler.module = { amd: function (t, r, n) { return 'define(["' + n + '"], function (Twig) {\n\tvar twig, templates;\ntwig = Twig.twig;\ntemplates = ' + e.compiler.wrap(t, r) + "\n\treturn templates;\n});" }, node: function (t, r) { return 'var twig = require("twig").twig;\nexports.template = ' + e.compiler.wrap(t, r) }, cjs2: function (t, r, n) { return 'module.declare([{ twig: "' + n + '" }], function (require, exports, module) {\n\tvar twig = require("twig").twig;\n\texports.template = ' + e.compiler.wrap(t, r) + "\n});" } }, e.compiler.wrap = function (e, t) { return 'twig({id:"' + e.replace('"', '\\"') + '", data:' + t + ", precompiled: true});\n" }, e }((Twig = function (e) { "use strict"; return e.exports = { VERSION: e.VERSION }, e.exports.twig = function (t) { var r = t.id, n = { strict_variables: t.strict_variables || !1, autoescape: null != t.autoescape && t.autoescape || !1, allowInlineIncludes: t.allowInlineIncludes || !1, rethrow: t.rethrow || !1, namespaces: t.namespaces }; if (e.cache && r && e.validateId(r), void 0 !== t.debug && (e.debug = t.debug), void 0 !== t.trace && (e.trace = t.trace), void 0 !== t.data) return e.Templates.parsers.twig({ data: t.data, path: t.hasOwnProperty("path") ? t.path : void 0, module: t.module, id: r, options: n }); if (void 0 !== t.ref) { if (void 0 !== t.id) throw new e.Error("Both ref and id cannot be set on a twig.js template."); return e.Templates.load(t.ref) } if (void 0 !== t.method) { if (!e.Templates.isRegisteredLoader(t.method)) throw new e.Error('Loader for "' + t.method + '" is not defined.'); return e.Templates.loadRemote(t.name || t.href || t.path || r || void 0, { id: r, method: t.method, parser: t.parser || "twig", base: t.base, module: t.module, precompiled: t.precompiled, async: t.async, options: n }, t.load, t.error) } return void 0 !== t.href ? e.Templates.loadRemote(t.href, { id: r, method: "ajax", parser: t.parser || "twig", base: t.base, module: t.module, precompiled: t.precompiled, async: t.async, options: n }, t.load, t.error) : void 0 !== t.path ? e.Templates.loadRemote(t.path, { id: r, method: "fs", parser: t.parser || "twig", base: t.base, module: t.module, precompiled: t.precompiled, async: t.async, options: n }, t.load, t.error) : void 0 }, e.exports.extendFilter = function (t, r) { e.filter.extend(t, r) }, e.exports.extendFunction = function (t, r) { e._function.extend(t, r) }, e.exports.extendTest = function (t, r) { e.test.extend(t, r) }, e.exports.extendTag = function (t) { e.logic.extend(t) }, e.exports.extend = function (t) { t(e) }, e.exports.compile = function (t, r) { var n, o = r.filename, i = r.filename; return n = new e.Template({ data: t, path: i, id: o, options: r.settings["twig options"] }), function (e) { return n.render(e) } }, e.exports.renderFile = function (t, r, n) { "function" == typeof r && (n = r, r = {}); var o = (r = r || {}).settings || {}, i = { path: t, base: o.views, load: function (e) { n(null, e.render(r)) } }, s = o["twig options"]; if (s) for (var p in s) s.hasOwnProperty(p) && (i[p] = s[p]); e.exports.twig(i) }, e.exports.__express = e.exports.renderFile, e.exports.cache = function (t) { e.cache = t }, e.exports.path = e.path, e }(Twig || {})) || {}); "undefined" != typeof module && module.declare ? module.declare([], function (e, t, r) { for (key in Twig.exports) Twig.exports.hasOwnProperty(key) && (t[key] = Twig.exports[key]) }) : "function" == typeof define && define.amd ? define(function () { return Twig.exports }) : "undefined" != typeof module && module.exports ? module.exports = Twig.exports : (window.twig = Twig.exports.twig, window.Twig = Twig.exports);

            return twig;
        }())
    ))
